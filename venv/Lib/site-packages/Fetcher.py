from sqlalchemy import create_engine
from sqlalchemy.types import DateTime, Numeric, VARCHAR
from mysql.connector import connect
from pandas import read_sql_table
from json import loads
from datetime import datetime as dt

class Fetcher:
    sql_dt_format = "%Y-%m-%d %H:%M:%S"

    _types_ = {"ohlc": {"Date": DateTime(), "Open": Numeric(16, 4), "High": Numeric(16, 4),
                        "Low": Numeric(16, 4), "Close": Numeric(16, 4), "Volume": Numeric(65, 4)},

               "guidance": {"symbol": VARCHAR(10),
                            **{col: DateTime() for col in
                               "first_available last_available cleaned analyzed checked updated".split()}},

                "symsrc": {"symbol": VARCHAR(10), "source": VARCHAR(10)}
               }

    VARCHAR = VARCHAR
    DateTime = DateTime
    Numeric = Numeric

    def __init__(self, database="test_1min_pricedata"):
        self.database = database
        self.engine = create_engine(
            f"mysql+mysqlconnector://root:root@localhost:3306/{database}",
            pool_recycle= 3600, pool_size= 5)
        self.conn = connect(user="root", password="root", host="localhost",
                            database=database)
        self.c = self.conn.cursor()
        self.refreshTables()

        now = dt.now()
        self.sqldtnow = self.sqldt(now)
        self.sqldnow = self.sqldtnow.split()[0]

    def refreshTables(self):
        self.c.execute("SHOW TABLES")
        self.Tables = [t[0] for t in self.c.fetchall()]

    def fetch(self, table, engine= None):
        engine = engine or self.engine
        df = read_sql_table(table.lower(), engine)

        if df.shape[0] and df.iloc[-1].isna().all():
            return df.iloc[:-1]
        else: return df

    def stash(self, table, df, if_exists, types, engine= None):
        if isinstance(types, str):
            types = self._types_[types]
        elif not isinstance(types, dict):
            raise ValueError("no types specified or incorrect format")

        if list(df.columns) != list(types.keys()):
            raise ValueError("columns and types don't match")

        engine = engine or self.engine
        df.to_sql(table.lower(), engine, if_exists= if_exists,
                  chunksize= 10000, dtype= types, index= False)
        print("saved ", table.lower())

    def sqldt(self, d):
        return d.strftime(self.sql_dt_format)
    def sqld(self, d):
        return self.sqldt(d).split()[0]

    def query(self, query, ix= None):
        self.c.execute(query)
        res = self.c.fetchall()
        if ix is None: return res if len(res)!= 1 else res[0]
        else:
            res = [r[ix] for r in res]
            return res if len(res)!= 1 else res[0]

    def columns(self, table):
        return self.query(f"DESC `{table.lower()}`", ix= 0)

    def execute(self, query, commit= True):
        self.c.execute(query)
        if commit: self.commit()

    def commit(self):
        self.conn.commit()

    def closeall(self):
        self.conn.close()
        self.engine.dispose()


class UpdateGeneralGuidance(Fetcher):
    def __init__(self, database = "general"):
        Fetcher.__init__(self, database)

    def first_available(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET first_available = {date} WHERE symbol = '{symbol}'")

    def last_available(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET last_available = {date} WHERE symbol = '{symbol}'")

    def cleaned(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET cleaned = {date} WHERE symbol = '{symbol}'")

    def analyzed(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET analyzed = {date} WHERE symbol = '{symbol}'")

    def checked(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET checked = {date} WHERE symbol = '{symbol}'")

    def updated(self, symbol, date=None):
        date = "NOW()" if date is None else f"'{self.sqldt(date)}'"
        self.execute(f"UPDATE guidance SET updated = {date} WHERE symbol = '{symbol}'")

    def getAdderIds(self) -> list:
        return self.query(
            f"SELECT adder, clientid, cleanerid FROM distribution WHERE day = '{self.sqldnow}'")

    def getAdderSymbols(self, adderid, date= None) -> list:
        if date is None: date = self.sqldnow
        else: date = self.sqldt(date).split()[0]

        symbols = self.query(
            f"SELECT symbols FROM distribution WHERE day = '{date}' AND adder = {adderid}",
            ix = 0)
        return loads(symbols)
    
    def getInitializerSymbols(self):
        return self.query("SELECT symbol FROM new", ix= 0)

    def getMaxDate(self, symbol):
        return self.query(f"SELECT DATE(last_available) FROM guidance"
                          f" WHERE symbol = '{symbol}'", ix= 0)

    def createRow(self, symbol, first, last):
        first, last = self.sqldt(first), self.sqldt(last)
        self.execute(f"INSERT INTO guidance(symbol, first_available, last_available)"
                     f" VALUES('{symbol.lower()}', '{first}', '{last}')")

    def markFaulty(self, symbol, problem):
        self.execute(f"INSERT INTO faulty VALUES('{symbol}', '{problem}')")

    def removeNew(self, symbol):
        self.execute(f"DELETE FROM new WHERE symbol = '{symbol}'")

Updater = UpdateGeneralGuidance()

