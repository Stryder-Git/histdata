from math import ceil
from datetime import datetime, timedelta, time

""" This is copied from the actual Project Folder
on January 12th 2021"""

class Time:

    RTH = 6.5   # num of hours in regular trading day
    RTD = 5     # num of days in regular trading week

    tdRTH = timedelta(hours= RTH)
    opentme = time(9,30)
    closetme = time(16,0)

    # Timedeltas for the full real times (1 week is 7 days)
    TFS = {"s": timedelta(seconds= 1), "m": timedelta(minutes= 1), "h": timedelta(hours= 1),
                       "D": timedelta(days= 1), "W": timedelta(weeks= 1)}

    # Timedeltas for trading times (1 Week is 5 days)
    TimeFrameDeltas = {"s": timedelta(seconds= 1), "m": timedelta(seconds= 60), "h": timedelta(seconds= 60*60),
                       "D": timedelta(seconds= 60*60*RTH), "W": timedelta(seconds= 60*60*RTH*RTD)}

    Intra = ["s","m","h"]

    def __init__(self, tfs= None):
        if tfs:
            self.run_Time_init_(tfs)

    def _makeadjtfdeltas(self):
        self.adjTFdeltas = {tf: int(tf[:-1]) * self.TimeFrameDeltas[tf[-1]]
                            for tf in self.timeframes}
        self.adjTFdeltas["1D"] = self.TimeFrameDeltas["D"]

    def temptfs(self, *tfs):
        self.timeframes = self._sorttimeframes(list(tfs))
        self._makeadjtfdeltas()

    def run_Time_init_(self, tfs):
        self.timeframes = self._sorttimeframes(list(tfs))
        self._makeadjtfdeltas()

        self.lowest = self.timeframes[0]
        self.highest = self.timeframes[-1]

        self.tfRatios = {tf: ceil(self.adjTFdeltas[tf] / self.adjTFdeltas[self.lowest])
                         for tf in self.timeframes}

    def _sorttimeframes(self, tfs= None):
        timeframes = tfs or self.timeframes
        if len(timeframes) > 1:
            if not tfs:
                timeframes.sort(key= lambda x: self.adjTFdeltas[x])
            else:
                timeframes.sort(key= lambda x: int(x[:-1])* self.TimeFrameDeltas[x[-1]])

        return timeframes

    def realTFdelta(self, tf):
        return self.TFS[tf[-1]] * int(tf[:-1])

    def isIntra(self, tf):
        return tf[-1] in self.Intra

    def nBarsPerRTD(self, tf):
        """ returns number of bars per regulard trading day
        for a given tf, which can either be timedelta or string"""
        if not isinstance(tf, timedelta):
            tf = self.TimeFrameDeltas[tf[-1]] * int(tf[:-1])

        return ceil(self.tdRTH/tf)

    def _todt(self, date, tme= (0,0)):
        tme = time(*tme) if not isinstance(tme, time) else tme
        return datetime.combine(date, tme)

    def opent(self, dte):
        return self._todt(dte, self.opentme)

    def closet(self, dte):
        return self._todt(dte, self.closetme)


if __name__ == "__main__":

    T = Time(["1m", "2D", "1h"])

    intr = T.isIntra("1m")

    print(intr)
