from Cleaner.Analyzer import Analyzer
from HistData.HistData import HistData
from Cleaner.mylogging import MissingDates

from numpy import append, timedelta64, split, delete, argwhere, setdiff1d
from threading import Event
from pandas import concat
from datetime import datetime as dt, time as dtt, date as ddt
from time import sleep
from itertools import count


class Cleaner(Analyzer, HistData):

    def __init__(self, clientid= 99999):
        Analyzer.__init__(self)
        HistData.__init__(self, clientid)
        self.Blocking(directreturn= False)
        self.datatoconcat = {}
        self.reqEvent = Event()
        self.missingdates = MissingDates
        self.nmissingandincomplete = {}
        self.validsymbol = True

    # def dropincompletedates(self, data):  
    #     incomplete = self.getincompleteDays(data)
    #     data.df["onlydates"] = data.df.index.date
    #     ix_to_drop = data.df[data.df["onlydates"].isin(incomplete)].index
    #     del data.df["onlydates"]
    #     return data.df.drop(ix_to_drop)

    def DatesToFill(self, data) -> list:
        missing = self.getmissingDays(data)
        incomplete = self.getincompleteDays(data)
        if missing.shape[0] or incomplete.shape[0]:
            arr =  append(missing, incomplete)
            print("missing before: ", missing.shape[0], "\n",
                  "incompl before: ", incomplete.shape[0])
            midct = dict(missing = missing.shape[0], incomplete = incomplete.shape[0])
            self.missingdates.info(f"{data.sym} before: {midct}")

            arr.sort()
            lastix, oneday = arr.shape[0]-1, timedelta64(1, "D")

            ixs = argwhere((arr[1:] - arr[:-1]) > oneday).flatten()
            oddones, ix_to_remove = [], []
            for i in ixs:
                if not i:
                    oddones.append(arr[i])
                    ix_to_remove.append(i)
                    continue
                i += 1
                if i == lastix:
                    oddones.append(arr[i])
                    ix_to_remove.append(i)
                else:
                    if arr[i + 1] - arr[i] > oneday:
                        oddones.append(arr[i])
                        ix_to_remove.append(i)

            arr = delete(arr, ix_to_remove)
            ixs = argwhere((arr[1:] - arr[:-1]) > oneday).flatten()
            if arr.shape[0]:
                ranges = [sub[[0, -1]].tolist() for sub in split(arr, ixs + 1)]
            else: ranges = []
            ranges.extend([[odd] * 2 for odd in oddones])

        else: ranges = []
        return ranges

    def _conv(self, start, end):
        if not isinstance(start, ddt): start = start.astype(dt)
        if not isinstance(end, ddt): end = end.astype(dt)

        start = dt.combine(start, dtt(0))
        end = dt.combine(end, dtt(0))
        return start, end

    def getData(self, data, tf, start, end):
        self.reqEvent.clear()
        self.get(data.sym, tf, start, end)
        if not self.reqEvent.wait(150):
            self.datatoconcat[data.sym].append("Timed Out")

        att = count(0)
        while isinstance(self.datatoconcat[data.sym][-1], str) and next(att) < 2:
            if "invalid symbol" == self.datatoconcat[data.sym][-1]:
                self.datatoconcat[data.sym] = self.datatoconcat[data.sym][:-1]
                self.validsymbol = False
                self.missingdates.info(f"{data.sym}: INVALID SYMBOL")
                print(f"{data.sym}: INVALID SYMBOL")
                break

            print(self.datatoconcat[data.sym][-1], " ", start, end)
            self.datatoconcat[data.sym] = self.datatoconcat[data.sym][:-1]
            sleep(10)
            self.reqEvent.clear()
            self.get(data.sym, tf, start, end)
            if not self.reqEvent.wait(150):
                self.datatoconcat[data.sym].append("Timed Out")

        if self.validsymbol and isinstance(self.datatoconcat[data.sym][-1], str):
            self.datatoconcat[data.sym] = self.datatoconcat[data.sym][:-1]

    def FillMissingData(self, data):
        self.validsymbol = True
        tofill = self.DatesToFill(data)
        self.missingdates.info(f"{data.sym}:\n{tofill}")
        self.datatoconcat[data.sym] = []
        if not tofill:
            self.validsymbol = False
            print("\nnothing to fill: ", len(tofill), "\n")

        nreqs = len(tofill); updlst =[]
        for nupd, dates in enumerate(tofill):
            start, end = self._conv(*dates)
            if not self.validsymbol: break
            self.getData(data, "1m", start, end)

            if upd := ((nupd + 1) / nreqs // .1):
                upd = int(upd * .1 * 100)
                if upd not in updlst: print(f"{upd}% done");  updlst.append(upd)

        if self.validsymbol:
            newdf = concat([data.df, *self.datatoconcat[data.sym]])
            newdf = newdf[~newdf.index.duplicated()].sort_index()
            missing, incomplete = self.missingandincomplete(newdf)

            print("missing after: ", missing.shape[0], "\n",
                  "incompl after: ", incomplete.shape[0])
            midct = dict(missing = missing.shape[0], incomplete = incomplete.shape[0])
            self.missingdates.info(f"{data.sym} after: {midct}")

            # to find the ones that weren't missing or incomplete before
            old_incompl = self.getincompleteDays(data)
            diff_incompl = setdiff1d(incomplete, old_incompl)
            old_missing = self.getmissingDays(data)
            diff_missing = setdiff1d(missing, old_missing)


            if diff_missing.shape[0] or diff_incompl.shape[0]:
                newly_msg = f"\nnewly missing: \n{diff_missing}\n" \
                            f"newly incomplete: \n{diff_incompl}"
                print(newly_msg)
                issues = [*diff_missing.tolist(), *diff_incompl.tolist()]
                self.missingdates.info(f"{data.sym}:\n{issues}")
                self.missingdates.info(f"{data.sym}:\n{newly_msg}")
                print("fixing issues")

                for d in issues:
                    start, end = self._conv(d, d)
                    self.getData(data, "1m", start, end)
                    if not self.validsymbol: break

                if self.validsymbol:
                    issuesdf = concat([data.df, *self.datatoconcat[data.sym]])
                    issuesdf = issuesdf[~issuesdf.index.duplicated()].sort_index()

                    if issuesdf.shape[0] > newdf.shape[0]:
                        newdf = issuesdf

                    missing, incomplete = self.missingandincomplete(newdf)
                    print("missing now: ", missing.shape[0], "\n",
                          "incompl now: ", incomplete.shape[0])
                    midct = dict(missinowng = missing.shape[0], incomplete = incomplete.shape[0])
                    self.missingdates.info(f"{data.sym} now: {midct}")

            return data._replace(df = newdf)
        return data

    def response(self, tf, sym, df):
        try:
            self.datatoconcat[sym].append(df)
            self.reqEvent.set()
        except KeyError:
            m = f"KEYERROR: {sym}: probably disconnected and received data after cache was already cleared"
            print(m)
            self.errors.info(m)

    def clear_cache(self, data):
        self._cleardates_counts(data)
        del self.datatoconcat[data.sym]



